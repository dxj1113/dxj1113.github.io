<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/code4t.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/code4.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/code4.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="机器学习,数学,深度学习,线性代数,概率,信息论,数理统计,最优化," />





  <link rel="alternate" href="/atom.xml" title="Eason Du's Notes" type="application/atom+xml" />






<meta name="description" content="概述我们知道，机器学习的特点就是：以计算机为工具和平台，以数据为研究对象，以学习方法为中心；是概率论、线性代数、数值计算、信息论、最优化理论和计算机科学等多个领域的交叉学科。所以本文就先介绍一下机器学习涉及到的一些最常用的的数学知识。">
<meta name="keywords" content="机器学习,数学,深度学习,线性代数,概率,信息论,数理统计,最优化">
<meta property="og:type" content="article">
<meta property="og:title" content="机器学习所需的数学基础">
<meta property="og:url" content="https://dxj1113.github.io/2017/07/14/机器学习的数学基础/index.html">
<meta property="og:site_name" content="Eason Du&#39;s Notes">
<meta property="og:description" content="概述我们知道，机器学习的特点就是：以计算机为工具和平台，以数据为研究对象，以学习方法为中心；是概率论、线性代数、数值计算、信息论、最优化理论和计算机科学等多个领域的交叉学科。所以本文就先介绍一下机器学习涉及到的一些最常用的的数学知识。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://pic3.zhimg.com/v2-dd3017aa861f53973da40d860ec93732_b.png">
<meta property="og:image" content="http://pic1.zhimg.com/v2-c0c16793d4662bfcdd7e112030096f94_b.jpg">
<meta property="og:image" content="http://pic2.zhimg.com/v2-e3e7a3aa9fb146d662591612b3cac465_b.png">
<meta property="og:image" content="http://pic1.zhimg.com/v2-a0811acc8ab121a3ad8f2e37ff6c37cc_b.png">
<meta property="og:image" content="http://pic3.zhimg.com/v2-a58c37c481e032bbb53ff17113754ef6_b.png">
<meta property="og:image" content="http://pic3.zhimg.com/v2-806fd987177e32a33e698caa74d69942_b.jpg">
<meta property="og:image" content="http://pic3.zhimg.com/v2-84eef0a858928f3cc28fd03bd7286b3a_b.png">
<meta property="og:image" content="http://pic3.zhimg.com/v2-adc57281fa54b0702906a8c42cbd7e5a_b.jpg">
<meta property="og:image" content="http://pic3.zhimg.com/v2-6f41bffde009999cbc370f7f38cab092_b.jpg">
<meta property="og:image" content="http://pic3.zhimg.com/v2-f35226b3e0fa018db6a4b233c51eccbe_b.png">
<meta property="og:image" content="http://pic1.zhimg.com/v2-608f89f47688c41e4c3f83cfad095c84_b.jpg">
<meta property="og:image" content="http://pic2.zhimg.com/v2-4116a3bda12faa5e2421ce27efb7fb71_b.png">
<meta property="og:image" content="http://pic3.zhimg.com/v2-f1b39d0aad4388433158679221f813d2_b.jpg">
<meta property="og:image" content="http://pic1.zhimg.com/v2-e61c38f10e34badf5b2c1f3b9c9bcfa0_b.png">
<meta property="og:image" content="http://pic3.zhimg.com/v2-e22ea8c565434e945a17a80bec5630b6_b.png">
<meta property="og:image" content="http://pic3.zhimg.com/v2-e908f9721cc82415fa7e70c763351f3a_b.jpg">
<meta property="og:image" content="http://pic2.zhimg.com/v2-71df54a8e32e172596dcaa07e6b31899_b.png">
<meta property="og:image" content="http://pic2.zhimg.com/v2-2891044fd02769c3148649e2a1a01fd5_b.png">
<meta property="og:updated_time" content="2018-01-09T02:10:15.727Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="机器学习所需的数学基础">
<meta name="twitter:description" content="概述我们知道，机器学习的特点就是：以计算机为工具和平台，以数据为研究对象，以学习方法为中心；是概率论、线性代数、数值计算、信息论、最优化理论和计算机科学等多个领域的交叉学科。所以本文就先介绍一下机器学习涉及到的一些最常用的的数学知识。">
<meta name="twitter:image" content="http://pic3.zhimg.com/v2-dd3017aa861f53973da40d860ec93732_b.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dxj1113.github.io/2017/07/14/机器学习的数学基础/"/>





  <title>机器学习所需的数学基础 | Eason Du's Notes</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/dxj1113"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/8b6b8ccc6da3aa5722903da7b58eb5ab1081adee/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Eason Du's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dxj1113.github.io/2017/07/14/机器学习的数学基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eason Du">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eason Du's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">机器学习所需的数学基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-14T09:55:32+08:00">
                2017-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们知道，机器学习的特点就是：以计算机为工具和平台，以数据为研究对象，以学习方法为中心；是概率论、线性代数、数值计算、信息论、最优化理论和计算机科学等多个领域的交叉学科。所以本文就先介绍一下机器学习涉及到的一些最常用的的数学知识。<br> <a id="more"></a></p>
<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h2><p>一个标量就是一个单独的数，一般用小写的的变量名称表示。</p>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>一个向量就是一列数，这些数是有序排列的。用过次序中的索引，我们可以确定每个单独的数。通常会赋予向量粗体的小写名称。当我们需要明确表示向量中的元素时，我们会将元素排列成一个方括号包围的纵柱：</p>
<p>我们可以把向量看作空间中的点，每个元素是不同的坐标轴上的坐标。</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>矩阵是二维数组，其中的每一个元素被两个索引而非一个所确定。我们通常会赋予矩阵粗体的大写变量名称，比如A。 如果一个实数矩阵高度为m，宽度为n，那么我们说$A\epsilon R^{m\times n} $。<br><img src="http://pic3.zhimg.com/v2-dd3017aa861f53973da40d860ec93732_b.png" alt="enter image description here"></p>
<h2 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h2><p>几何代数中定义的张量是基于向量和矩阵的推广，通俗一点理解的话，我们可以将标量视为零阶张量，矢量视为一阶张量，那么矩阵就是二阶张量。</p>
<p>例如，可以将任意一张彩色图片表示成一个三阶张量，三个维度分别是图片的高度、宽度和色彩数据。将这张图用张量表示出来，就是最下方的那张表格：<br><img src="http://pic1.zhimg.com/v2-c0c16793d4662bfcdd7e112030096f94_b.jpg" alt="enter image description here"><br>其中表的横轴表示图片的宽度值，这里只截取0~319；表的纵轴表示图片的高度值，这里只截取0~4；表格中每个方格代表一个像素点，比如第一行第一列的表格数据为[1.0,1.0,1.0]，代表的就是RGB三原色在图片的这个位置的取值情况（即R=1.0，G=1.0，B=1.0）。</p>
<p>当然我们还可以将这一定义继续扩展，即：我们可以用四阶张量表示一个包含多张图片的数据集，这四个维度分别是：图片在数据集中的编号，图片高度、宽度，以及色彩数据。</p>
<p>张量在深度学习中是一个很重要的概念，因为它是一个深度学习框架中的一个核心组件，后续的所有运算和优化算法几乎都是基于张量进行的。</p>
<h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><p>有时我们需要衡量一个向量的大小。在机器学习中，我们经常使用被称为范数(norm) 的函数衡量矩阵大小。Lp 范数如下：</p>
<script type="math/tex; mode=display">\left| \left| x \right| \right| _{p}^{} =\left( \sum_{i}^{}{\left| x_{i}  \right| ^{p} }  \right) _{}^{\frac{1}{p} }</script><p>所以：</p>
<p>L1范数$\left| \left| x \right| \right|$ ：为x向量各个元素绝对值之和；</p>
<p>L2范数$\left| \left| x \right|  \right| _{2}$ ：为x向量各个元素平方和的开方。</p>
<h2 id="特征分解"><a href="#特征分解" class="headerlink" title="特征分解"></a>特征分解</h2><p>许多数学对象可以通过将它们分解成多个组成部分。特征分解是使用最广的矩阵分解之一，即将矩阵分解成一组特征向量和特征值。</p>
<p>方阵A的特征向量是指与A相乘后相当于对该向量进行缩放的非零向量$\nu$ ：</p>
<script type="math/tex; mode=display">A\nu =\lambda \nu</script><p>标量$\lambda$ 被称为这个特征向量对应的特征值。</p>
<p>使用特征分解去分析矩阵A时，得到特征向量构成的矩阵V和特征值构成的向量$\lambda$ ，我们可以重新将A写作：</p>
<script type="math/tex; mode=display">A=Vdiag\left( \lambda  \right) V^{-1}</script><h2 id="奇异值分解（SVD）"><a href="#奇异值分解（SVD）" class="headerlink" title="奇异值分解（SVD）"></a>奇异值分解（SVD）</h2><p>除了特征分解，还有一种分解矩阵的方法，被称为奇异值分解（SVD）。将矩阵分解为奇异向量和奇异值。通过奇异分解，我们会得到一些类似于特征分解的信息。然而，奇异分解有更广泛的应用。</p>
<p>每个实数矩阵都有一个奇异值分解，但不一定都有特征分解。例如，非方阵的矩阵没有特征分解，这时我们只能使用奇异值分解。<br>奇异分解与特征分解类似，只不过这回我们将矩阵A分解成三个矩阵的乘积：</p>
<p>$A=UDV^{T} $<br>假设A是一个$m\times n$矩阵，那么U是一个$m\times m$矩阵，D是一个$m\times n$矩阵，V是一个$n\times n$矩阵。</p>
<p>这些矩阵每一个都拥有特殊的结构，其中U和V都是正交矩阵，D是对角矩阵（注意，D不一定是方阵）。对角矩阵D对角线上的元素被称为矩阵A的奇异值。矩阵U的列向量被称为左奇异向量，矩阵V 的列向量被称右奇异向量。</p>
<p>SVD最有用的一个性质可能是拓展矩阵求逆到非方矩阵上。另外，SVD可用于推荐系统中。</p>
<h2 id="Moore-Penrose伪逆"><a href="#Moore-Penrose伪逆" class="headerlink" title="Moore-Penrose伪逆"></a>Moore-Penrose伪逆</h2><p>对于非方矩阵而言，其逆矩阵没有定义。假设在下面问题中，我们想通过矩阵A的左逆B来求解线性方程：</p>
<script type="math/tex; mode=display">Ax=y</script><p>等式两边同时左乘左逆B后，得到：</p>
<script type="math/tex; mode=display">x=By</script><p>是否存在唯一的映射将A映射到B取决于问题的形式。</p>
<p>如果矩阵A的行数大于列数，那么上述方程可能没有解；如果矩阵A的行数小于列数，那么上述方程可能有多个解。</p>
<p>Moore-Penrose伪逆使我们能够解决这种情况，矩阵A的伪逆定义为：</p>
<p>但是计算伪逆的实际算法没有基于这个式子，而是使用下面的公式：</p>
<p>其中，矩阵U，D 和V 是矩阵A奇异值分解后得到的矩阵。对角矩阵D 的伪逆D+ 是其非零元素取倒之后再转置得到的。</p>
<h2 id="几种常用的距离"><a href="#几种常用的距离" class="headerlink" title="几种常用的距离"></a>几种常用的距离</h2><p>设有两个n维变量<script type="math/tex">A=[x_{11}, x_{12},...,x_{1n} ]</script>和<script type="math/tex">B=[ x_{21} ,x_{22} ,...,x_{2n}]</script> ，则下面可以定义一些常用的距离公式：</p>
<ol>
<li>曼哈顿距离</li>
</ol>
<p>曼哈顿距离也称为城市街区距离，数学定义如下：</p>
<script type="math/tex; mode=display">d_{12} =\sum_{k=1}^{n}{\left| x_{1k}-x_{2k} \right| }</script><p>曼哈顿距离的Python实现：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from numpy import *</span><br><span class="line">vector1 = mat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">vector2 = mat([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">print sum(<span class="name">abs</span>(<span class="name">vector1-vector2</span>))</span><br></pre></td></tr></table></figure>
<ol>
<li>欧氏距离</li>
</ol>
<p>欧氏距离其实就是L2范数，数学定义如下：</p>
<script type="math/tex; mode=display">d_{12} =\sqrt{\sum_{k=1}^{n}{\left( x_{1k} -x_{2k}  \right) ^{2} } }</script><p>欧氏距离的Python实现：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from numpy import *</span><br><span class="line">vector1 = mat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">vector2 = mat([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">print sqrt((vector1-vector2)*(vector1-vector2).T)</span><br></pre></td></tr></table></figure>
<ol>
<li>闵可夫斯基距离</li>
</ol>
<p>从严格意义上讲，闵可夫斯基距离不是一种距离，而是一组距离的定义：</p>
<script type="math/tex; mode=display">d_{12} =\sqrt[p]{\sum_{k=1}^{n}{\left( x_{1k} -x_{2k}  \right) ^{p} } }</script><p>实际上，当p=1时，就是曼哈顿距离；当p=2时，就是欧式距离。</p>
<ol>
<li>切比雪夫距离</li>
</ol>
<p>切比雪夫距离就是$L_{\varpi}$ ，即无穷范数，数学表达式如下：</p>
<script type="math/tex; mode=display">d_{12} =max\left( \left| x_{1k}-x_{2k} \right|  \right)</script><p>切比雪夫距离额Python实现如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from numpy import *</span><br><span class="line">vector1 = mat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">vector2 = mat([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">print sqrt(<span class="name">abs</span>(<span class="name">vector1-vector2</span>).max)</span><br></pre></td></tr></table></figure>
<ol>
<li>夹角余弦</li>
</ol>
<p>夹角余弦的取值范围为[-1,1]，可以用来衡量两个向量方向的差异；夹角余弦越大，表示两个向量的夹角越小；当两个向量的方向重合时，夹角余弦取最大值1；当两个向量的方向完全相反时，夹角余弦取最小值-1。</p>
<p>机器学习中用这一概念来衡量样本向量之间的差异，其数学表达式如下：</p>
<script type="math/tex; mode=display">cos\theta =\frac{AB}{\left| A \right| \left|B \right| } =\frac{\sum_{k=1}^{n}{x_{1k}x_{2k} } }{\sqrt{\sum_{k=1}^{n}{x_{1k}^{2} } } \sqrt{\sum_{k=1}^{n}{x_{2k}^{2} } } }</script><p>夹角余弦的Python实现：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from numpy import *</span><br><span class="line">vector1 = mat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">vector2 = mat([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">print dot(<span class="name">vector1</span>,vector2)/(<span class="name">linalg</span>.norm(<span class="name">vector1</span>)*linalg.norm(vector2))</span><br></pre></td></tr></table></figure>
<ol>
<li>汉明距离</li>
</ol>
<p>汉明距离定义的是两个字符串中不相同位数的数目。</p>
<p>例如：字符串‘1111’与‘1001’之间的汉明距离为2。</p>
<p>信息编码中一般应使得编码间的汉明距离尽可能的小。</p>
<p>汉明距离的Python实现：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from numpy import *</span><br><span class="line">matV = mat([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">smstr = nonzero(matV[<span class="number">0</span>]-matV[<span class="number">1</span>])</span><br><span class="line">print smstr</span><br></pre></td></tr></table></figure>
<ol>
<li>杰卡德相似系数</li>
</ol>
<p>两个集合A和B的交集元素在A和B的并集中所占的比例称为两个集合的杰卡德相似系数，用符号J(A,B)表示，数学表达式为：</p>
<script type="math/tex; mode=display">J\left( A,B \right) =\frac{\left| A\cap B\right| }{\left|A\cup B \right| }</script><p>杰卡德相似系数是衡量两个集合的相似度的一种指标。一般可以将其用在衡量样本的相似度上。</p>
<ol>
<li>杰卡德距离</li>
</ol>
<p>与杰卡德相似系数相反的概念是杰卡德距离，其定义式为：</p>
<script type="math/tex; mode=display">J_{\sigma} =1-J\left( A,B \right) =\frac{\left| A\cup B \right| -\left| A\cap B \right| }{\left| A\cup B \right| }</script><p>杰卡德距离的Python实现：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from numpy import *</span><br><span class="line">import scipy.spatial.distance as dist</span><br><span class="line">matV = mat([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">print dist.pdist(matV,'jaccard')</span><br></pre></td></tr></table></figure>
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><p><a href="https://www.amazon.com/Introduction-Linear-Algebra-Gilbert-Strang/dp/0980232775" target="_blank" rel="noopener">Introduction to Linear Algebra, Fifth Edition by  Gilbert Strang</a></p>
<h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><p>待补充</p>
<h1 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h1><h2 id="为什么使用概率？"><a href="#为什么使用概率？" class="headerlink" title="为什么使用概率？"></a>为什么使用概率？</h2><p>概率论是用于表示不确定性陈述的数学框架，即它是对事物不确定性的度量。</p>
<p>在人工智能领域，我们主要以两种方式来使用概率论。首先，概率法则告诉我们AI系统应该如何推理，所以我们设计一些算法来计算或者近似由概率论导出的表达式。其次，我们可以用概率和统计从理论上分析我们提出的AI系统的行为。</p>
<p>计算机科学的许多分支处理的对象都是完全确定的实体，但机器学习却大量使用概率论。实际上如果你了解机器学习的工作原理你就会觉得这个很正常。因为机器学习大部分时候处理的都是不确定量或随机量。</p>
<h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><p>随机变量可以随机地取不同值的变量。我们通常用小写字母来表示随机变量本身，而用带数字下标的小写字母来表示随机变量能够取到的值。例如，<script type="math/tex">x_{1}</script>  和<script type="math/tex">x_{2}</script>  都是随机变量X可能的取值。<br>对于向量值变量，我们会将随机变量写成X，它的一个值为x。就其本身而言，一个随机变量只是对可能的状态的描述；它必须伴随着一个概率分布来指定每个状态的可能性。</p>
<p>随机变量可以是离散的或者连续的。</p>
<h2 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h2><p>给定某随机变量的取值范围，概率分布就是导致该随机事件出现的可能性。<br>从机器学习的角度来看，概率分布就是符合随机变量取值范围的某个对象属于某个类别或服从某种趋势的可能性。</p>
<h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><p>很多情况下，我们感兴趣的是某个事件在给定其它事件发生时出现的概率，这种概率叫条件概率。<br>我们将给定X=x时Y=y发生的概率记为$P\left( Y=y|X=x \right) $，这个概率可以通过下面的公式来计算：</p>
<script type="math/tex; mode=display">P\left( Y=y|X=x  \right) =\frac{P\left( Y=y,X=x \right) }{P\left( X=x \right) }</script><h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h2><p>先看看什么是“先验概率”和“后验概率”，以一个例子来说明：</p>
<p>假设某种病在人群中的发病率是0.001，即1000人中大概会有1个人得病，则有： P(患病) = 0.1%；即：在没有做检验之前，我们预计的患病率为P(患病)=0.1%，这个就叫作”先验概率”。</p>
<p>再假设现在有一种该病的检测方法，其检测的准确率为95%；即：如果真的得了这种病，该检测法有95%的概率会检测出阳性，但也有5%的概率检测出阴性；或者反过来说，但如果没有得病，采用该方法有95%的概率检测出阴性，但也有5%的概率检测为阳性。用概率条件概率表示即为：P(显示阳性|患病)=95%</p>
<p>现在我们想知道的是：在做完检测显示为阳性后，某人的患病率P(患病|显示阳性)，这个其实就称为”后验概率”。</p>
<p>而这个叫贝叶斯的人其实就是为我们提供了一种可以利用先验概率计算后验概率的方法，我们将其称为“贝叶斯公式”，如下：</p>
<script type="math/tex; mode=display">P\left( B|A \right) =\frac{P\left( A|B \right)P\left( B\right)  }{P\left( A \right) }</script><p>在这个例子里就是：</p>
<p><img src="http://pic2.zhimg.com/v2-e3e7a3aa9fb146d662591612b3cac465_b.png" alt="enter image description here"><br>贝叶斯公式贯穿了机器学习中随机问题分析的全过程。从文本分类到概率图模型，其基本分类都是贝叶斯公式。</p>
<p>这里需要说明的是，上面的计算中除了利用了贝叶斯公式外，还利用了“全概率公式”，即：</p>
<p>$P\left( A \right) =P\left( A|B \right)+P\left( A|\bar{B}  \right)  $</p>
<h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><p>在概率论和统计学中，数学期望是试验中每次可能结果的概率乘以其结果的总和。它是最基本的数学特征之一，反映随机变量平均值的大小。</p>
<p>假设X是一个离散随机变量，其可能的取值有：<script type="math/tex">\left\{ x_{1} ,x_{2} ,......,x_{n}  \right\}</script>，各个取值对应的概率取值为：<script type="math/tex">P\left( x_{k} \right)</script>  ,<script type="math/tex">k=1,2,......,n</script>，则其数学期望被定义为：</p>
<script type="math/tex; mode=display">E\left(X \right) =\sum_{k=1}^{n}{x_{k} P\left( x_{k}  \right) }</script><p>假设X是一个连续型随机变量，其概率密度函数为<script type="math/tex">P\left( x \right)</script> 则其数学期望被定义为：</p>
<script type="math/tex; mode=display">E\left( x \right) =\int_{-\varpi }^{+\varpi } xf\left( x \right) dx</script><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><p>概率中，方差用来衡量随机变量与其数学期望之间的偏离程度；统计中的方差为样本方差，是各个样本数据分别与其平均数之差的平方和的平均数。数学表达式如下：</p>
<script type="math/tex; mode=display">Var\left( x \right) =E\left\{ \left[ x-E\left( x \right)  \right] ^{2}   \right\} =E\left( x^{2}  \right) -\left[ E\left( x \right)  \right] ^{2}</script><h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>在概率论和统计学中，协方差被用于衡量两个随机变量X和Y之间的总体误差。数学定义式为：</p>
<script type="math/tex; mode=display">Cov\left( X,Y \right) =E\left[ \left( X-E\left[ X \right]  \right) \left( Y-E\left[ Y \right]  \right) \right] =E\left[ XY \right] -E\left[ X \right] E\left[ Y \right]</script><h2 id="常见分布函数"><a href="#常见分布函数" class="headerlink" title="常见分布函数"></a>常见分布函数</h2><ol>
<li>0-1分布</li>
</ol>
<p>0-1分布是单个二值型离散随机变量的分布，其概率分布函数为：</p>
<script type="math/tex; mode=display">P\left( X=1 \right) =pP\left( X=0 \right) =1-p</script><ol>
<li>几何分布</li>
</ol>
<p>几何分布是离散型概率分布，其定义为：在n次伯努利试验中，试验k次才得到第一次成功的机率。即：前k-1次皆失败，第k次成功的概率。其概率分布函数为：</p>
<script type="math/tex; mode=display">P\left( X=k \right) =\left( 1-p \right) ^{k-1} p</script><p>性质：</p>
<script type="math/tex; mode=display">E\left( X \right) =\frac{1}{p} Var\left( X \right) =\frac{1-p}{p^{2} }</script><ol>
<li>二项分布</li>
</ol>
<p>二项分布即重复n次伯努利试验，各次试验之间都相互独立，并且每次试验中只有两种可能的结果，而且这两种结果发生与否相互对立。如果每次试验时，事件发生的概率为p，不发生的概率为1-p，则n次重复独立试验中发生k次的概率为：</p>
<script type="math/tex; mode=display">P\left( X=k \right) =C_{n}^{k} p^{k} \left( 1-p \right) ^{n-k}</script><p>性质：</p>
<script type="math/tex; mode=display">E\left( X \right) =npVar\left( X \right) =np\left( 1-p \right)</script><ol>
<li>高斯分布</li>
</ol>
<p>高斯分布又叫正态分布，其曲线呈钟型，两头低，中间高，左右对称因其曲线呈钟形，如下图所示：</p>
<p><img src="http://pic1.zhimg.com/v2-a0811acc8ab121a3ad8f2e37ff6c37cc_b.png" alt="enter image description here"><br>若随机变量X服从一个数学期望为$\mu$ ，方差为$\sigma ^{2} $的正态分布，则我们将其记为：$N\left( \mu ,\sigma^{2}  \right) $。其期望值$\mu$ 决定了正态分布的位置，其标准差$\sigma$ （方差的开方）决定了正态分布的幅度。</p>
<ol>
<li>指数分布</li>
</ol>
<p>指数分布是事件的时间间隔的概率，它的一个重要特征是无记忆性。例如：如果某一元件的寿命的寿命为T，已知元件使用了t小时，它总共使用至少t+s小时的条件概率，与从开始使用时算起它使用至少s小时的概率相等。下面这些都属于指数分布：</p>
<p>婴儿出生的时间间隔<br>网站访问的时间间隔<br>奶粉销售的时间间隔<br>指数分布的公式可以从泊松分布推断出来。如果下一个婴儿要间隔时间t，就等同于t之内没有任何婴儿出生，即：</p>
<script type="math/tex; mode=display">P\left( X\geq t \right) =P\left( N\left( t \right) =0 \right) =\frac{\left( \lambda t \right) ^{0}\cdot e^{-\lambda t}  }{0!}=e^{-\lambda t}</script><p>则：</p>
<script type="math/tex; mode=display">P\left( X\leq t \right) =1-P\left( X\geq t \right) =1-e^{-\lambda t}</script><p>如：接下来15分钟，会有婴儿出生的概率为：</p>
<script type="math/tex; mode=display">P\left( X\leq \frac{1}{4} \right) =1-e^{-3\cdot \frac{1}{4} } \approx 0.53</script><p>指数分布的图像如下：</p>
<p><img src="http://pic3.zhimg.com/v2-a58c37c481e032bbb53ff17113754ef6_b.png" alt="enter image description here"></p>
<ol>
<li>泊松分布</li>
</ol>
<p>日常生活中，大量事件是有固定频率的，比如：</p>
<p>某医院平均每小时出生3个婴儿<br>某网站平均每分钟有2次访问<br>某超市平均每小时销售4包奶粉<br>它们的特点就是，我们可以预估这些事件的总数，但是没法知道具体的发生时间。已知平均每小时出生3个婴儿，请问下一个小时，会出生几个？有可能一下子出生6个，也有可能一个都不出生，这是我们没法知道的。</p>
<p>泊松分布就是描述某段时间内，事件具体的发生概率。其概率函数为：</p>
<script type="math/tex; mode=display">P\left( N\left( t \right) =n \right) =\frac{\left( \lambda t \right) ^{n}e^{-\lambda t}  }{n!}</script><p>其中：</p>
<p>P表示概率，N表示某种函数关系，t表示时间，n表示数量，1小时内出生3个婴儿的概率，就表示为$ P(N(1) = 3) $；λ 表示事件的频率。</p>
<p>还是以上面医院平均每小时出生3个婴儿为例，则$\lambda =3$；</p>
<p>那么，接下来两个小时，一个婴儿都不出生的概率可以求得为：</p>
<script type="math/tex; mode=display">P\left( N\left(2 \right) =0 \right) =\frac{\left( 3\cdot 2 \right) ^{o} \cdot e^{-3\cdot 2} }{0!} \approx 0.0025</script><p>同理，我们可以求接下来一个小时，至少出生两个婴儿的概率：</p>
<script type="math/tex; mode=display">P\left( N\left( 1 \right) \geq 2 \right) =1-P\left( N\left( 1 \right)=0  \right) - P\left( N\left( 1 \right)=1  \right)\approx 0.8</script><h2 id="Lagrange乘子法"><a href="#Lagrange乘子法" class="headerlink" title="Lagrange乘子法"></a>Lagrange乘子法</h2><p>对于一般的求极值问题我们都知道，求导等于0就可以了。但是如果我们不但要求极值，还要求一个满足一定约束条件的极值，那么此时就可以构造Lagrange函数，其实就是把约束项添加到原函数上，然后对构造的新函数求导。</p>
<p>对于一个要求极值的函数$f\left( x,y \right) $，图上的蓝圈就是这个函数的等高图，就是说<script type="math/tex">f\left( x,y \right) =c_{1} ,c_{2} ,...,c_{n}</script> 分别代表不同的数值(每个值代表一圈，等高图)，我要找到一组<script type="math/tex">\left( x,y \right)</script> ，使它的<script type="math/tex">c_{i}</script>值越大越好，但是这点必须满足约束条件<script type="math/tex">g\left( x,y \right)</script>（在黄线上）。<br><img src="http://pic3.zhimg.com/v2-806fd987177e32a33e698caa74d69942_b.jpg" alt="enter image description here"><br>也就是说f(x,y)和g(x,y)相切，或者说它们的梯度$▽f$和$▽g$平行，因此它们的梯度（偏导）成倍数关系；那我么就假设为<script type="math/tex">\lambda</script> 倍，然后把约束条件加到原函数后再对它求导，其实就等于满足了下图上的式子。</p>
<h2 id="最大似然法"><a href="#最大似然法" class="headerlink" title="最大似然法"></a>最大似然法</h2><p>最大似然也称为最大概似估计，即：在“模型已定，参数θ未知”的情况下，通过观测数据估计未知参数θ 的一种思想或方法。</p>
<p>其基本思想是： 给定样本取值后，该样本最有可能来自参数<script type="math/tex">\theta</script> 为何值的总体。即：寻找<script type="math/tex">\tilde{\theta } _{ML}</script> 使得观测到样本数据的可能性最大。</p>
<p>举个例子，假设我们要统计全国人口的身高，首先假设这个身高服从服从正态分布，但是该分布的均值与方差未知。由于没有足够的人力和物力去统计全国每个人的身高，但是可以通过采样（所有的采样要求都是独立同分布的），获取部分人的身高，然后通过最大似然估计来获取上述假设中的正态分布的均值与方差。</p>
<p>求极大似然函数估计值的一般步骤：</p>
<ol>
<li>写出似然函数；<br><img src="http://pic3.zhimg.com/v2-84eef0a858928f3cc28fd03bd7286b3a_b.png" alt="enter image description here"></li>
<li>对似然函数取对数；</li>
<li>两边同时求导数；</li>
<li>令导数为0解出似然方程。<br>最大似然估计也是统计学习中经验风险最小化的例子。如果模型为条件概率分布，损失函数定义为对数损失函数，经验风险最小化就等价于最大似然估计。</li>
</ol>
<h2 id="延伸-1"><a href="#延伸-1" class="headerlink" title="延伸"></a>延伸</h2><h3 id="书籍推荐-1"><a href="#书籍推荐-1" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><p><a href="https://www.amazon.com/Think-Bayes-Bayesian-Statistics-Python/dp/1449370780/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1500024334&amp;sr=1-1&amp;keywords=think%20bayes" target="_blank" rel="noopener">Think Bayes: Bayesian Statistics in Python by Allen B. Downey</a><br><a href="https://www.amazon.com/Probability-Cambridge-Statistical-Probabilistic-Mathematics/dp/0521765390/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1500024425&amp;sr=1-1&amp;keywords=Probability%20-%20Theory%20and%20Examples" target="_blank" rel="noopener">Probability - Theory and Examples, 4th Edition - Rick.Durrett</a></p>
<h3 id="论文-1"><a href="#论文-1" class="headerlink" title="论文"></a>论文</h3><p>待补充</p>
<h1 id="信息论"><a href="#信息论" class="headerlink" title="信息论"></a>信息论</h1><p>信息论是应用数学的一个分支，主要研究的是对一个信号能够提供信息的多少进行量化。如果说概率使我们能够做出不确定性的陈述以及在不确定性存在的情况下进行推理，那信息论就是使我们能够量化概率分布中不确定性的总量。</p>
<p>1948年，香农引入信息熵，将其定义为离散随机事件的出现概率。一个系统越是有序，信息熵就越低；反之，一个系统越是混乱，信息熵就越高。所以说，信息熵可以被认为是系统有序化程度的一个度量。</p>
<h2 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h2><p>如果一个随机变量X的可能取值为<script type="math/tex">X=\left\{ x_{1},x_{2} ,.....,x_{n}   \right\}</script> ，其概率分布为<script type="math/tex">P\left( X=x_{i}  \right) =p_{i} ,i=1,2,.....,n</script>，则随机变量X的熵定义为<script type="math/tex">H(X)</script>：</p>
<script type="math/tex; mode=display">H\left( X \right) =-\sum_{i=1}^{n}{P\left( x_{i}  \right) logP\left( x_{i}  \right) } =\sum_{i=1}^{n}{P\left( x_{i}  \right) \frac{1}{logP\left( x_{i}  \right) } }</script><h2 id="联合熵"><a href="#联合熵" class="headerlink" title="联合熵"></a>联合熵</h2><p>两个随机变量X和Y的联合分布可以形成联合熵，定义为联合自信息的数学期望，它是二维随机变量XY的不确定性的度量，用$H(X,Y)$表示：</p>
<script type="math/tex; mode=display">H\left( X,Y \right) =-\sum_{i=1}^{n}{\sum_{j=1}^{n}{P\left( x_{i} ,y_{j}  \right)} logP\left( x_{i},y_{j}   \right)  }</script><h2 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h2><p>在随机变量X发生的前提下，随机变量Y发生新带来的熵，定义为Y的条件熵，用H(Y|X)表示：</p>
<script type="math/tex; mode=display">H\left(Y|X \right) =-\sum_{x,y}^{}{P\left( x,y \right) logP\left( y|x \right) }</script><p>条件熵用来衡量在已知随机变量X的条件下，随机变量Y的不确定性。</p>
<p>实际上，熵、联合熵和条件熵之间存在以下关系：</p>
<script type="math/tex; mode=display">H\left( Y|X \right) =H\left( X,Y\right) -H\left( X \right)</script><p>推导过程如下：<br><img src="http://pic3.zhimg.com/v2-adc57281fa54b0702906a8c42cbd7e5a_b.jpg" alt="enter image description here"><br>其中：</p>
<p>第二行推到第三行的依据是边缘分布$P(x)$等于联合分布$P(x,y)$的和；<br>第三行推到第四行的依据是把公因子$logP(x)$乘进去，然后把x,y写在一起；<br>第四行推到第五行的依据是：因为两个$sigma$都有$P(x,y)$，故提取公因子$P(x,y)$放到外边，然后把里边的$-（log P(x,y) - log P(x)）$写成$- log (P(x,y) / P(x) ) $；<br>第五行推到第六行的依据是：$P(x,y) = P(x) * P(y|x)，故P(x,y) / P(x) = P(y|x)$。<br>4-4、相对熵</p>
<p>相对熵又称互熵、交叉熵、KL散度、信息增益，是描述两个概率分布P和Q差异的一种方法，记为$D(P||Q)$。在信息论中，$D(P||Q)$表示当用概率分布Q来拟合真实分布P时，产生的信息损耗，其中P表示真实分布，Q表示P的拟合分布。</p>
<p>对于一个离散随机变量的两个概率分布P和Q来说，它们的相对熵定义为：</p>
<script type="math/tex; mode=display">D\left( P||Q \right) =\sum_{i=1}^{n}{P\left( x_{i}  \right) log\frac{P\left( x_{i}  \right) }{Q\left( x_{i}  \right) } }</script><p>注意：$D(P||Q) ≠ D(Q||P)$</p>
<h2 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h2><p>两个随机变量X，Y的互信息定义为X，Y的联合分布和各自独立分布乘积的相对熵称为互信息，用$I(X,Y)$表示。互信息是信息论里一种有用的信息度量方式，它可以看成是一个随机变量中包含的关于另一个随机变量的信息量，或者说是一个随机变量由于已知另一个随机变量而减少的不肯定性。</p>
<script type="math/tex; mode=display">I\left( X,Y \right) =\sum_{x\in X}^{}{\sum_{y\in Y}^{}{P\left( x,y \right) } log\frac{P\left( x,y \right) }{P\left( x \right) P\left( y \right) } }</script><p>互信息、熵和条件熵之间存在以下关系： $H\left( Y|X \right) =H\left( Y \right) -I\left( X,Y \right) $</p>
<p>推导过程如下：<br><img src="http://pic3.zhimg.com/v2-6f41bffde009999cbc370f7f38cab092_b.jpg" alt="enter image description here"><br>通过上面的计算过程发现有：$H(Y|X) = H(Y) - I(X,Y)$，又由前面条件熵的定义有：$H(Y|X) = H(X,Y) - H(X)$，于是有$I(X,Y)= H(X) + H(Y) - H(X,Y)$，此结论被多数文献作为互信息的定义。</p>
<h2 id="最大熵模型"><a href="#最大熵模型" class="headerlink" title="最大熵模型"></a>最大熵模型</h2><p>最大熵原理是概率模型学习的一个准则，它认为：学习概率模型时，在所有可能的概率分布中，熵最大的模型是最好的模型。通常用约束条件来确定模型的集合，所以，最大熵模型原理也可以表述为：在满足约束条件的模型集合中选取熵最大的模型。</p>
<p>前面我们知道，若随机变量X的概率分布是$P\left( x_{i}  \right)$ ，则其熵定义如下：</p>
<script type="math/tex; mode=display">H\left( X \right) =-\sum_{i=1}^{n}{P\left( x_{i}  \right) logP\left( x_{i}  \right) } =\sum_{i=1}^{n}{P\left( x_{i}  \right) \frac{1}{logP\left( x_{i}  \right) } }</script><p>熵满足下列不等式：</p>
<script type="math/tex; mode=display">0\leq H\left( X \right) \leq log\left| X \right|</script><p>式中，|X|是X的取值个数，当且仅当X的分布是均匀分布时右边的等号成立。也就是说，当X服从均匀分布时，熵最大。</p>
<p>直观地看，最大熵原理认为：要选择概率模型，首先必须满足已有的事实，即约束条件；在没有更多信息的情况下，那些不确定的部分都是“等可能的”。最大熵原理通过熵的最大化来表示等可能性；“等可能”不易操作，而熵则是一个可优化的指标。</p>
<h2 id="延伸-2"><a href="#延伸-2" class="headerlink" title="延伸"></a>延伸</h2><h3 id="书籍推荐-2"><a href="#书籍推荐-2" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><p><a href="https://www.amazon.com/s/ref=nb_sb_ss_i_1_11?url=search-alias=stripbooks&amp;field-keywords=information%20theory&amp;sprefix=information,stripbooks,342&amp;crid=3M2IMSN5L5WWW" target="_blank" rel="noopener">Information Theory: A Tutorial IntroductionFeb by James V Stone</a></p>
<h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><h1 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h1><h2 id="上溢和下溢"><a href="#上溢和下溢" class="headerlink" title="上溢和下溢"></a>上溢和下溢</h2><p>在数字计算机上实现连续数学的基本困难是：我们需要通过有限数量的位模式来表示无限多的实数，这意味着我们在计算机中表示实数时几乎都会引入一些近似误差。在许多情况下，这仅仅是舍入误差。如果在理论上可行的算法没有被设计为最小化舍入误差的累积，可能会在实践中失效，因此舍入误差是有问题的，特别是在某些操作复合时。</p>
<p>一种特别毁灭性的舍入误差是下溢。当接近零的数被四舍五入为零时发生下溢。许多函数会在其参数为零而不是一个很小的正数时才会表现出质的不同。例如，我们通常要避免被零除。</p>
<p>另一个极具破坏力的数值错误形式是上溢(overflow)。当大量级的数被近似为<script type="math/tex">\varpi</script> 或<script type="math/tex">-\varpi</script> 时发生上溢。进一步的运算通常将这些无限值变为非数字。</p>
<p>必须对上溢和下溢进行数值稳定的一个例子是softmax 函数。softmax 函数经常用于预测与multinoulli分布相关联的概率，定义为：</p>
<p>当式中的<script type="math/tex">x_{i}</script> 都是很小的负数时，<script type="math/tex">e^{x_{i} }</script>就会发生下溢，这意味着上面函数的分母会变成0，导致结果是未定的；同理，当式中的<script type="math/tex">x_{i}</script> 是很大的正数时，<script type="math/tex">e^{x_{i} }</script> 就会发生上溢导致结果是未定的。</p>
<h2 id="计算复杂性与NP问题"><a href="#计算复杂性与NP问题" class="headerlink" title="计算复杂性与NP问题"></a>计算复杂性与NP问题</h2><ol>
<li>算法复杂性<br>现实中大多数问题都是离散的数据集，为了反映统计规律，有时数据量很大，而且多数目标函数都不能简单地求得解析解。这就带来一个问题：算法的复杂性。</li>
</ol>
<p>算法理论被认为是解决各类现实问题的方法论。衡量算法有两个重要的指标：时间复杂度和空间复杂度，这是对算法执行所需要的两类资源——时间和空间的估算。</p>
<p>一般，衡量问题是否可解的重要指标是：该问题能否在多项式时间内求解，还是只能在指数时间内求解？在各类算法理论中，通常使用多项式时间算法即可解决的问题看作是易解问题，需要指数时间算法解决的问题看作是难解问题。</p>
<p>指数时间算法的计算时间随着问题规模的增长而呈指数化上升，这类问题虽然有解，但并不适用于大规模问题。所以当前算法研究的一个重要任务就是将指数时间算法变换为多项式时间算法。</p>
<ol>
<li>确定性和非确定性</li>
</ol>
<p>除了问题规模与运算时间的比较，衡量一个算法还需要考虑确定性和非确定性的概念。</p>
<p>这里先介绍一下“自动机”的概念。自动机实际上是指一种基于状态变化进行迭代的算法。在算法领域常把这类算法看作一个机器，比较知名的有图灵机、玻尔兹曼机、支持向量机等。</p>
<p>所谓确定性，是指针对各种自动机模型，根据当时的状态和输入，若自动机的状态转移是唯一确定的，则称确定性；若在某一时刻自动机有多个状态可供选择，并尝试执行每个可选择的状态，则称为非确定性。</p>
<p>换个说法就是：确定性是程序每次运行时产生下一步的结果是唯一的，因此返回的结果也是唯一的；非确定性是程序在每个运行时执行的路径是并行且随机的，所有路径都可能返回结果，也可能只有部分返回结果，也可能不返回结果，但是只要有一个路径返回结果，那么算法就结束。</p>
<p>在求解优化问题时，非确定性算法可能会陷入局部最优。</p>
<ol>
<li>NP问题</li>
</ol>
<p>有了时间上的衡量标准和状态转移的确定性与非确定性的概念，我们来定义一下问题的计算复杂度。</p>
<p>P类问题就是能够以多项式时间的确定性算法来对问题进行判定或求解，实现它的算法在每个运行状态都是唯一的，最终一定能够确定一个唯一的结果——最优的结果。</p>
<p>NP问题是指可以用多项式时间的非确定性算法来判定或求解，即这类问题求解的算法大多是非确定性的，但时间复杂度有可能是多项式级别的。</p>
<p>但是，NP问题还要一个子类称为NP完全问题，它是NP问题中最难的问题，其中任何一个问题至今都没有找到多项式时间的算法。</p>
<p>机器学习中多数算法都是针对NP问题（包括NP完全问题）的。</p>
<h2 id="数值计算-1"><a href="#数值计算-1" class="headerlink" title="数值计算"></a>数值计算</h2><p>上面已经分析了，大部分实际情况中，计算机其实都只能做一些近似的数值计算，而不可能找到一个完全精确的值，这其实有一门专门的学科来研究这个问题，这门学科就是——数值分析（有时也叫作“计算方法”）；运用数值分析解决问题的过程为：实际问题→数学模型→数值计算方法→程序设计→上机计算求出结果。</p>
<p>计算机在做这些数值计算的过程中，经常会涉及到的一个东西就是“迭代运算”，即通过不停的迭代计算，逐渐逼近真实值（当然是要在误差收敛的情况下）。</p>
<h2 id="延伸-3"><a href="#延伸-3" class="headerlink" title="延伸"></a>延伸</h2><h3 id="书籍推荐-3"><a href="#书籍推荐-3" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><p><a href="https://www.amazon.com/Numerical-Analysis-Richard-L-Burden/dp/1305253663/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1500024656&amp;sr=1-1&amp;keywords=numerical%20analysis" target="_blank" rel="noopener">Numerical AnalysisJan by Richard L. Burden and J. Douglas Faires</a></p>
<h3 id="论文-2"><a href="#论文-2" class="headerlink" title="论文"></a>论文</h3><p>待补充</p>
<h1 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h1><p>本节介绍机器学习中的一种重要理论——最优化方法。</p>
<h2 id="最优化理论"><a href="#最优化理论" class="headerlink" title="最优化理论"></a>最优化理论</h2><p>无论做什么事，人们总希望以最小的代价取得最大的收益。在解决一些工程问题时，人们常会遇到多种因素交织在一起与决策目标相互影响的情况；这就促使人们创造一种新的数学理论来应对这一挑战，也因此，最早的优化方法——线性规划诞生了。</p>
<h2 id="最优化问题的数学描述"><a href="#最优化问题的数学描述" class="headerlink" title="最优化问题的数学描述"></a>最优化问题的数学描述</h2><p>最优化的基本数学模型如下：<br><img src="http://pic3.zhimg.com/v2-f35226b3e0fa018db6a4b233c51eccbe_b.png" alt="enter image description here"><br>它有三个基本要素，即：</p>
<ul>
<li>设计变量：x是一个实数域范围内的n维向量，被称为决策变量或问题的解；</li>
<li>目标函数：<script type="math/tex">f(x)</script>为目标函数；</li>
<li>约束条件：<script type="math/tex">h_{i} \left( x \right) =0</script>称为等式约束，<script type="math/tex">g_{i} \left( x \right) \leq</script> 0为不等式约束，<script type="math/tex">i=0,1,2,......</script></li>
</ul>
<h2 id="凸集与凸集分离定理"><a href="#凸集与凸集分离定理" class="headerlink" title="凸集与凸集分离定理"></a>凸集与凸集分离定理</h2><ol>
<li>凸集<br><img src="http://pic1.zhimg.com/v2-608f89f47688c41e4c3f83cfad095c84_b.jpg" alt="enter image description here"><br>实数域R上（或复数C上）的向量空间中，如果集合S中任两点的连线上的点都在S内，则称集合S为凸集，如下图所示：</li>
</ol>
<p>数学定义为：</p>
<p>设集合$D\subset R^{n}$ ，若对于任意两点$x,y\in D$，及实数$\lambda \left( 0\leq \lambda \leq 1 \right) $都有：</p>
<script type="math/tex; mode=display">\lambda x+\left( 1-\lambda  \right) y\in D</script><p>则称集合D为凸集。</p>
<ol>
<li>超平面和半空间</li>
</ol>
<p>实际上，二维空间的超平面就是一条线（可以使曲线），三维空间的超平面就是一个面（可以是曲面）。其数学表达式如下：</p>
<p>超平面：<script type="math/tex">H=\left\{ x\in R^{n} |a_{1} +a_{2}+...+a_{n} =b  \right\}</script></p>
<p>半空间：<script type="math/tex">H^{+} =\left\{ x\in R^{n} |a_{1} +a_{2}+...+a_{n} \geq b  \right\}</script></p>
<ol>
<li>凸集分离定理</li>
</ol>
<p>所谓两个凸集分离，直观地看是指两个凸集合没有交叉和重合的部分，因此可以用一张超平面将两者隔在两边，如下图所示：<br><img src="http://pic2.zhimg.com/v2-4116a3bda12faa5e2421ce27efb7fb71_b.png" alt="enter image description here"></p>
<ol>
<li>凸函数</li>
</ol>
<p>凸函数就是一个定义域在某个向量空间的凸子集C上的实值函数。<br><img src="http://pic3.zhimg.com/v2-f1b39d0aad4388433158679221f813d2_b.jpg" alt="enter image description here"></p>
<p>数学定义为：</p>
<p>对于函数$f(x)$，如果其定义域C是凸的，且对于$∀x,y∈C，0\leq \alpha \leq 1$， 有：</p>
<script type="math/tex; mode=display">f\left( \theta x+\left( 1-\theta  \right) y \right) \leq \theta f\left( x \right) +\left( 1-\theta  \right) f\left( y \right)</script><p>则f(x)是凸函数。<br>注：如果一个函数是凸函数，则其局部最优点就是它的全局最优点。这个性质在机器学习算法优化中有很重要的应用，因为机器学习模型最后就是在求某个函数的全局最优点，一旦证明该函数（机器学习里面叫“损失函数”）是凸函数，那相当于我们只用求它的局部最优点了。</p>
<h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><ol>
<li>引入</li>
</ol>
<p>前面讲数值计算的时候提到过，计算机在运用迭代法做数值计算（比如求解某个方程组的解）时，只要误差能够收敛，计算机最后经过一定次数的迭代后是可以给出一个跟真实解很接近的结果的。</p>
<p>这里进一步提出一个问题，如果我们得到的目标函数是非线性的情况下，按照哪个方向迭代求解误差的收敛速度会最快呢？</p>
<p>答案就是沿梯度方向。这就引入了我们的梯度下降法。</p>
<ol>
<li>梯度下降法</li>
</ol>
<p>在多元微分学中，梯度就是函数的导数方向。</p>
<p>梯度法是求解无约束多元函数极值最早的数值方法，很多机器学习的常用算法都是以它作为算法框架，进行改进而导出更为复杂的优化方法。</p>
<p>在求解目标函数$f\left( x \right)$ 的最小值时，为求得目标函数的一个凸函数，在最优化方法中被表示为：</p>
<script type="math/tex; mode=display">minf\left( x \right)</script><p>根据导数的定义，函数$f\left( x \right) $的导函数就是目标函数在x上的变化率。在多元的情况下，目标函数$f\left( x,y,z \right) $在某点的梯度$grad f\left( x,y,z \right) =\left( \frac{\partial f}{\partial x}  ,\frac{\partial f}{\partial y},\frac{\partial f}{\partial z}  \right)$ 是一个由各个分量的偏导数构成的向量，负梯度方向是$f\left( x,y,z \right) $减小最快的方向。<br><img src="http://pic1.zhimg.com/v2-e61c38f10e34badf5b2c1f3b9c9bcfa0_b.png" alt="enter image description here"><br>如上图所示，当需要求<script type="math/tex">f\left( x \right)</script> 的最小值时（机器学习中的<script type="math/tex">f\left( x \right)</script> 一般就是损失函数，而我们的目标就是希望损失函数最小化），我们就可以先任意选取一个函数的初始点<script type="math/tex">x_{0}</script> （三维情况就是<script type="math/tex">\left( x_{0} ,y_{0} ,z_{0}  \right)</script> ），让其沿着途中红色箭头（负梯度方向）走，依次到<script type="math/tex">x_{1} ，x_{2} ，...，x_{n}</script>（迭代n次）这样可最快达到极小值点。</p>
<p>梯度下降法过程如下：</p>
<p>输入：目标函数<script type="math/tex">f\left( x \right)</script> ，梯度函数<script type="math/tex">g\left( x \right) =grad f\left( x \right)</script>，计算精度<script type="math/tex">\varepsilon</script></p>
<p>输出：<script type="math/tex">f\left( x \right)</script> 的极小值点<script type="math/tex">x^{*}</script></p>
<p>1、任取取初始值<script type="math/tex">x_{0}</script> ，置k=0；<br>2、计算<script type="math/tex">f\left( x_{k}  \right)</script> ；<br>3、计算梯度<script type="math/tex">g_{k} =grad f\left( x_{k}  \right)</script> ，当<script type="math/tex">\left| \left| g_{k} \right|  \right| <\varepsilon</script> 时停止迭代，令<script type="math/tex">x^{*} =x_{k}</script>；<br>4、否则令<script type="math/tex">P_{k} =-g_{k}</script>，求<script type="math/tex">\lambda _{k}</script> 使<script type="math/tex">f\left( x_{k+1} \right) =minf\left( x_{k} +\lambda _{k} P_{k}  \right)</script>；<br>5、置<script type="math/tex">x_{k+1} =x_{k} +\lambda _{k} P_{k}</script> ，计算<script type="math/tex">f\left( x_{k+1}\right)</script>，当<script type="math/tex">\left| \left| f\left( x_{k+1}\right) -f\left( x_{k}\right)  \right| \right| <\varepsilon</script> 或<script type="math/tex">\left| \left| x_{k+1} -x_{k}  \right|  \right| <\varepsilon</script> 时，停止迭代，令<script type="math/tex">x^{*} =x_{k+1}</script> ；<br>6、否则，置$k=k+1$，转3。</p>
<h2 id="随机梯度下降算法"><a href="#随机梯度下降算法" class="headerlink" title="随机梯度下降算法"></a>随机梯度下降算法</h2><p>上面可以看到，在梯度下降法的迭代中，除了梯度值本身的影响外，还有每一次取的步长\lambda _{k} 也很关键：步长值取得越大，收敛速度就会越快，但是带来的可能后果就是容易越过函数的最优点，导致发散；步长取太小，算法的收敛速度又会明显降低。因此我们希望找到一种比较好的方法能够平衡步长。</p>
<p>随机梯度下降法并没有新的算法理论，仅仅是引进了随机样本抽取方式，并提供了一种动态步长取值策略。目的就是又要优化精度，又要满足收敛速度。</p>
<p>也就是说，上面的批量梯度下降法每次迭代时都会计算训练集中所有的数据，而随机梯度下降法每次迭代只是随机取了训练集中的一部分样本数据进行梯度计算，这样做最大的好处是可以避免有时候陷入局部极小值的情况（因为批量梯度下降法每次都使用全部数据，一旦到了某个局部极小值点可能就停止更新了；而随机梯度法由于每次都是随机取部分数据，所以就算局部极小值点，在下一步也还是可以跳出）</p>
<p>两者的关系可以这样理解：随机梯度下降方法以损失很小的一部分精确度和增加一定数量的迭代次数为代价，换取了总体的优化效率的提升。增加的迭代次数远远小于样本的数量。</p>
<h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><h3 id="牛顿法介绍"><a href="#牛顿法介绍" class="headerlink" title="牛顿法介绍"></a>牛顿法介绍</h3><p>牛顿法也是求解无约束最优化问题常用的方法，最大的优点是收敛速度快。</p>
<p>从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。通俗地说，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法 每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以， 可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。<br><img src="http://pic3.zhimg.com/v2-e22ea8c565434e945a17a80bec5630b6_b.png" alt="enter image description here"><br>或者从几何上说，牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。</p>
<h3 id="牛顿法的推导"><a href="#牛顿法的推导" class="headerlink" title="牛顿法的推导"></a>牛顿法的推导</h3><p>将目标函数$f\left( x \right)$  在$x_{k}$ 处进行二阶泰勒展开，可得：</p>
<script type="math/tex; mode=display">f\left( x \right) =f\left( x_{k}  \right) +f^{'} \left( x_{k}  \right) \left( x-x_{k}  \right) +\frac{1}{2} f^{''}\left( x_{k}  \right)  \left( x-x_{k}  \right) ^{2}</script><p>因为目标函数$f\left( x \right)$有极值的必要条件是在极值点处一阶导数为0，即：$f^{‘} \left( x \right) =0$</p>
<p>所以对上面的展开式两边同时求导（注意x才是变量，<script type="math/tex">x_{k}</script> 是常量<script type="math/tex">\Rightarrow f^{'} \left( x_{k}  \right) ,f^{''} \left( x_{k}  \right)</script> 都是常量），并令<script type="math/tex">f^{'} \left( x \right) =0</script>可得：</p>
<script type="math/tex; mode=display">f^{'} \left( x_{k} \right) +f^{''} \left( x_{k} \right) \left( x-x_{k} \right) =0</script><p>即：</p>
<script type="math/tex; mode=display">x=x_{k} -\frac{f^{'} \left( x_{k}  \right) }{f^{''} \left( x_{k}  \right) }</script><p>于是可以构造如下的迭代公式：</p>
<script type="math/tex; mode=display">x_{k+1} =x_{k} -\frac{f^{'} \left( x_{k}  \right) }{f^{''} \left( x_{k}  \right) }</script><p>这样，我们就可以利用该迭代式依次产生的序列<script type="math/tex">\left\{x_{1},x_{2},....,   x_{k}  \right\}</script>才逐渐逼近<script type="math/tex">f\left( x \right)</script> 的极小值点了。</p>
<p>牛顿法的迭代示意图如下：</p>
<p><img src="http://pic3.zhimg.com/v2-e908f9721cc82415fa7e70c763351f3a_b.jpg" alt="enter image description here"><br>上面讨论的是2维情况，高维情况的牛顿迭代公式是：</p>
<p>式中， $▽f$是$f\left( x \right)$ 的梯度，即：<br><img src="http://pic2.zhimg.com/v2-71df54a8e32e172596dcaa07e6b31899_b.png" alt="enter image description here"><br>H是Hessen矩阵，即：<br><img src="http://pic2.zhimg.com/v2-2891044fd02769c3148649e2a1a01fd5_b.png" alt="enter image description here"></p>
<h3 id="牛顿法的过程"><a href="#牛顿法的过程" class="headerlink" title="牛顿法的过程"></a>牛顿法的过程</h3><ol>
<li>给定初值$x_{0}$ 和精度阈值$\varepsilon$ ，并令$k=0$；</li>
<li>计算<script type="math/tex">x_{k}</script> 和<script type="math/tex">H_{k}</script> ；</li>
<li>若<script type="math/tex">\left| \left| g_{k}  \right|  \right| <\varepsilon</script> 则停止迭代；否则确定搜索方向：<script type="math/tex">d_{k} =-H_{k}^{-1} \cdot g_{k}</script> ；</li>
<li>计算新的迭代点：<script type="math/tex">x_{k+1} =x_{k} +d_{k}</script> ；</li>
<li>令$k=k+1$，转至2。<h2 id="阻尼牛顿法"><a href="#阻尼牛顿法" class="headerlink" title="阻尼牛顿法"></a>阻尼牛顿法</h2></li>
</ol>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>注意到，牛顿法的迭代公式中没有步长因子，是定步长迭代。对于非二次型目标函数，有时候会出现<script type="math/tex">f\left( x_{k+1}  \right) >f\left( x_{k}  \right)</script>的情况，这表明，原始牛顿法不能保证函数值稳定的下降。在严重的情况下甚至会造成序列发散而导致计算失败。</p>
<p>为消除这一弊病，人们又提出阻尼牛顿法。阻尼牛顿法每次迭代的方向仍然是<script type="math/tex">x_{k}</script> ，但每次迭代会沿此方向做一维搜索，寻求最优的步长因子<script type="math/tex">\lambda _{k}</script> ，即：</p>
<script type="math/tex; mode=display">\lambda _{k} = minf\left( x_{k}  +\lambda d_{k}  \right)</script><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><ol>
<li>给定初值<script type="math/tex">x_{0}</script> 和精度阈值<script type="math/tex">\varepsilon</script> ，并令<script type="math/tex">k=0</script>；</li>
<li>计算<script type="math/tex">g_{k}</script>（<script type="math/tex">f\left( x \right) 在x_{k}</script> 处的梯度值）和<script type="math/tex">H_{k}</script> ；</li>
<li>若<script type="math/tex">\left| \left| g_{k}  \right|  \right| <\varepsilon</script> 则停止迭代；否则确定搜索方向：<script type="math/tex">d_{k} =-H_{k}^{-1} \cdot g_{k}</script> ；</li>
<li>利用<script type="math/tex">d_{k} =-H_{k}^{-1} \cdot g_{k}</script> 得到步长<script type="math/tex">\lambda _{k}</script> ，并令<script type="math/tex">x_{k+1} =x_{k} +\lambda _{k} d_{k}</script></li>
<li>令$k=k+1$，转至2。<h2 id="拟牛顿法"><a href="#拟牛顿法" class="headerlink" title="拟牛顿法"></a>拟牛顿法</h2></li>
</ol>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>由于牛顿法每一步都要求解目标函数的Hessen矩阵的逆矩阵，计算量比较大（求矩阵的逆运算量比较大），因此提出一种改进方法，即通过正定矩阵近似代替Hessen矩阵的逆矩阵，简化这一计算过程，改进后的方法称为拟牛顿法。</p>
<h3 id="拟牛顿法的推导"><a href="#拟牛顿法的推导" class="headerlink" title="拟牛顿法的推导"></a>拟牛顿法的推导</h3><p>先将目标函数在$x_{k+1}$ 处展开，得到：</p>
<script type="math/tex; mode=display">f\left( x \right) =f\left( x_{k+1}  \right) +f^{'} \left( x_{k+1}  \right) \left( x-x_{k+1}  \right) +\frac{1}{2} f^{''}\left( x_{k+1}  \right)  \left( x-x_{k+1}  \right) ^{2}</script><p>两边同时取梯度，得：</p>
<script type="math/tex; mode=display">f^{'}\left( x \right) = f^{'} \left( x_{k+1} \right) +f^{''} \left( x_{k+1} \right) \left( x-x_{k+1} \right)</script><p>取上式中的$x=x_{k}$ ，得：</p>
<script type="math/tex; mode=display">f^{'}\left( x_{k}  \right) = f^{'} \left( x_{k+1} \right) +f^{''} \left( x_{k+1} \right) \left( x-x_{k+1} \right)</script><p>即：</p>
<script type="math/tex; mode=display">g_{k+1} -g_{k} =H_{k+1} \cdot \left( x_{k+1} -x_{k}  \right)</script><p>可得：</p>
<script type="math/tex; mode=display">H_{k}^{-1} \cdot \left( g_{k+1} -g_{k}  \right) =x_{k+1} -x_{k}</script><p>上面这个式子称为“拟牛顿条件”，由它来对Hessen矩阵做约束。</p>
<h2 id="延伸-4"><a href="#延伸-4" class="headerlink" title="延伸"></a>延伸</h2><h3 id="书籍推荐-4"><a href="#书籍推荐-4" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><p><a href="https://www.amazon.com/Convex-Optimization-Stephen-Boyd/dp/0521833787/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1500024918&amp;sr=1-1&amp;keywords=convex%20optimization" target="_blank" rel="noopener">Convex OptimizationMar by Stephen Boyd and Lieven Vandenberghe</a></p>
<h3 id="论文-3"><a href="#论文-3" class="headerlink" title="论文"></a>论文</h3><p>待补充<br>——EOF——</p>

      
    </div>
    
    
    

    


<div>
  
    <div>

<div style="text-align:center;color: #ccc;font-size:14px;">-------------------------------------------------EOF<i class="fa fa-paw"></i>感谢您的阅读----------------------------------------------------</div>

</div>

  
</div>

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>感谢打赏，你的支持是我最大的动力</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Eason Du 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Eason Du 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/机器学习/" rel="tag"># 机器学习</a>
          
            <a href="/tags/数学/" rel="tag"># 数学</a>
          
            <a href="/tags/深度学习/" rel="tag"># 深度学习</a>
          
            <a href="/tags/线性代数/" rel="tag"># 线性代数</a>
          
            <a href="/tags/概率/" rel="tag"># 概率</a>
          
            <a href="/tags/信息论/" rel="tag"># 信息论</a>
          
            <a href="/tags/数理统计/" rel="tag"># 数理统计</a>
          
            <a href="/tags/最优化/" rel="tag"># 最优化</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/12/用hexo-github搭建个人博客/" rel="next" title="用hexo+github搭建个人博客">
                <i class="fa fa-chevron-left"></i> 用hexo+github搭建个人博客
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/14/处理hexo与mathjax兼容问题/" rel="prev" title="处理hexo与mathjax兼容问题">
                处理hexo与mathjax兼容问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Eason Du</p>
              <p class="site-description motion-element" itemprop="description">即使天空暗淡，阳光也会照耀圣西罗。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dxj1113" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:xijun.du@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://music.163.com/" title="网易云音乐" target="_blank">网易云音乐</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/" title="Github" target="_blank">Github</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.google.com/" title="Google" target="_blank">Google</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.zhihu.com/" title="知乎" target="_blank">知乎</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线性代数"><span class="nav-number">2.</span> <span class="nav-text">线性代数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#标量"><span class="nav-number">2.1.</span> <span class="nav-text">标量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向量"><span class="nav-number">2.2.</span> <span class="nav-text">向量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#矩阵"><span class="nav-number">2.3.</span> <span class="nav-text">矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#张量"><span class="nav-number">2.4.</span> <span class="nav-text">张量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#范数"><span class="nav-number">2.5.</span> <span class="nav-text">范数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特征分解"><span class="nav-number">2.6.</span> <span class="nav-text">特征分解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#奇异值分解（SVD）"><span class="nav-number">2.7.</span> <span class="nav-text">奇异值分解（SVD）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Moore-Penrose伪逆"><span class="nav-number">2.8.</span> <span class="nav-text">Moore-Penrose伪逆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几种常用的距离"><span class="nav-number">2.9.</span> <span class="nav-text">几种常用的距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延伸"><span class="nav-number">2.10.</span> <span class="nav-text">延伸</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#书籍推荐"><span class="nav-number">2.10.1.</span> <span class="nav-text">书籍推荐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#论文"><span class="nav-number">2.10.2.</span> <span class="nav-text">论文</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#概率"><span class="nav-number">3.</span> <span class="nav-text">概率</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么使用概率？"><span class="nav-number">3.1.</span> <span class="nav-text">为什么使用概率？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机变量"><span class="nav-number">3.2.</span> <span class="nav-text">随机变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概率分布"><span class="nav-number">3.3.</span> <span class="nav-text">概率分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件概率"><span class="nav-number">3.4.</span> <span class="nav-text">条件概率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#贝叶斯公式"><span class="nav-number">3.5.</span> <span class="nav-text">贝叶斯公式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#期望"><span class="nav-number">3.6.</span> <span class="nav-text">期望</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方差"><span class="nav-number">3.7.</span> <span class="nav-text">方差</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协方差"><span class="nav-number">3.8.</span> <span class="nav-text">协方差</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见分布函数"><span class="nav-number">3.9.</span> <span class="nav-text">常见分布函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lagrange乘子法"><span class="nav-number">3.10.</span> <span class="nav-text">Lagrange乘子法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最大似然法"><span class="nav-number">3.11.</span> <span class="nav-text">最大似然法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延伸-1"><span class="nav-number">3.12.</span> <span class="nav-text">延伸</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#书籍推荐-1"><span class="nav-number">3.12.1.</span> <span class="nav-text">书籍推荐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#论文-1"><span class="nav-number">3.12.2.</span> <span class="nav-text">论文</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#信息论"><span class="nav-number">4.</span> <span class="nav-text">信息论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#熵"><span class="nav-number">4.1.</span> <span class="nav-text">熵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#联合熵"><span class="nav-number">4.2.</span> <span class="nav-text">联合熵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件熵"><span class="nav-number">4.3.</span> <span class="nav-text">条件熵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互信息"><span class="nav-number">4.4.</span> <span class="nav-text">互信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最大熵模型"><span class="nav-number">4.5.</span> <span class="nav-text">最大熵模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延伸-2"><span class="nav-number">4.6.</span> <span class="nav-text">延伸</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#书籍推荐-2"><span class="nav-number">4.6.1.</span> <span class="nav-text">书籍推荐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#"><span class="nav-number">4.7.</span> <span class="nav-text">#</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数值计算"><span class="nav-number">5.</span> <span class="nav-text">数值计算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#上溢和下溢"><span class="nav-number">5.1.</span> <span class="nav-text">上溢和下溢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算复杂性与NP问题"><span class="nav-number">5.2.</span> <span class="nav-text">计算复杂性与NP问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值计算-1"><span class="nav-number">5.3.</span> <span class="nav-text">数值计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延伸-3"><span class="nav-number">5.4.</span> <span class="nav-text">延伸</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#书籍推荐-3"><span class="nav-number">5.4.1.</span> <span class="nav-text">书籍推荐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#论文-2"><span class="nav-number">5.4.2.</span> <span class="nav-text">论文</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#最优化"><span class="nav-number">6.</span> <span class="nav-text">最优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#最优化理论"><span class="nav-number">6.1.</span> <span class="nav-text">最优化理论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最优化问题的数学描述"><span class="nav-number">6.2.</span> <span class="nav-text">最优化问题的数学描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#凸集与凸集分离定理"><span class="nav-number">6.3.</span> <span class="nav-text">凸集与凸集分离定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#梯度下降算法"><span class="nav-number">6.4.</span> <span class="nav-text">梯度下降算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机梯度下降算法"><span class="nav-number">6.5.</span> <span class="nav-text">随机梯度下降算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#牛顿法"><span class="nav-number">6.6.</span> <span class="nav-text">牛顿法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#牛顿法介绍"><span class="nav-number">6.6.1.</span> <span class="nav-text">牛顿法介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#牛顿法的推导"><span class="nav-number">6.6.2.</span> <span class="nav-text">牛顿法的推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#牛顿法的过程"><span class="nav-number">6.6.3.</span> <span class="nav-text">牛顿法的过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻尼牛顿法"><span class="nav-number">6.7.</span> <span class="nav-text">阻尼牛顿法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引入"><span class="nav-number">6.7.1.</span> <span class="nav-text">引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法过程"><span class="nav-number">6.7.2.</span> <span class="nav-text">算法过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拟牛顿法"><span class="nav-number">6.8.</span> <span class="nav-text">拟牛顿法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-1"><span class="nav-number">6.8.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拟牛顿法的推导"><span class="nav-number">6.8.2.</span> <span class="nav-text">拟牛顿法的推导</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延伸-4"><span class="nav-number">6.9.</span> <span class="nav-text">延伸</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#书籍推荐-4"><span class="nav-number">6.9.1.</span> <span class="nav-text">书籍推荐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#论文-3"><span class="nav-number">6.9.2.</span> <span class="nav-text">论文</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eason Du</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
